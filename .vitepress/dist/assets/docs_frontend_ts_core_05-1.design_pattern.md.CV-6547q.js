import{_ as i,c as t,o as r,ah as n}from"./chunks/framework.Dd68kSU-.js";const c=JSON.parse('{"title":"TypeScript 设计模式简介","description":"TypeScript设计模式简介","frontmatter":{"title":"TypeScript 设计模式简介","description":"TypeScript设计模式简介"},"headers":[],"relativePath":"docs/frontend/ts/core/05-1.design_pattern.md","filePath":"docs/frontend/ts/core/05-1.design_pattern.md","lastUpdated":1752940917000}'),e={name:"docs/frontend/ts/core/05-1.design_pattern.md"};function o(a,l,s,p,g,u){return r(),t("div",null,l[0]||(l[0]=[n('<h1 id="设计模式-design-patterns" tabindex="-1">设计模式 (Design Patterns) <a class="header-anchor" href="#设计模式-design-patterns" aria-label="Permalink to “设计模式 (Design Patterns)”">​</a></h1><p>设计模式是软件设计中常见问题的典型解决方案, 是经过验证的、可重用的设计经验总结, 以下是主要设计模式的分类和概述:</p><h2 id="创建型模式-creational-patterns" tabindex="-1">创建型模式 (Creational Patterns) <a class="header-anchor" href="#创建型模式-creational-patterns" aria-label="Permalink to “创建型模式 (Creational Patterns)”">​</a></h2><ol><li><p><strong>单例模式 (Singleton)</strong></p><ul><li>确保一个类只有一个实例, 并提供全局访问点</li><li>应用场景: 配置管理、日志记录器、数据库连接</li></ul></li><li><p><strong>工厂方法模式 (Factory Method)</strong></p><ul><li>定义创建对象的接口, 让子类决定实例化哪个类</li><li>应用场景: 框架设计、跨平台UI组件创建</li></ul></li><li><p><strong>抽象工厂模式 (Abstract Factory)</strong></p><ul><li>创建相关或依赖对象的家族, 而不需指定具体类</li><li>应用场景: 跨平台GUI工具包、数据库访问层</li></ul></li><li><p><strong>建造者模式 (Builder)</strong></p><ul><li>分步骤构建复杂对象, 允许不同表示</li><li>应用场景: 复杂对象创建(如SQL查询构造器)</li></ul></li><li><p><strong>原型模式 (Prototype)</strong></p><ul><li>通过复制现有对象来创建新对象</li><li>应用场景: 对象创建成本高时(如数据库查询结果)</li></ul></li></ol><h2 id="结构型模式-structural-patterns" tabindex="-1">结构型模式 (Structural Patterns) <a class="header-anchor" href="#结构型模式-structural-patterns" aria-label="Permalink to “结构型模式 (Structural Patterns)”">​</a></h2><ol><li><p><strong>适配器模式 (Adapter)</strong></p><ul><li>使接口不兼容的类能够一起工作</li><li>应用场景: 集成旧系统、使用第三方库</li></ul></li><li><p><strong>桥接模式 (Bridge)</strong></p><ul><li>将抽象与实现分离, 使它们可以独立变化</li><li>应用场景: 跨平台应用、多数据库支持</li></ul></li><li><p><strong>组合模式 (Composite)</strong></p><ul><li>以树形结构组合对象, 表示部分-整体层次</li><li>应用场景: UI组件、文件系统表示</li></ul></li><li><p><strong>装饰器模式 (Decorator)</strong></p><ul><li>动态地给对象添加额外职责</li><li>应用场景: 流处理、权限检查</li></ul></li><li><p><strong>外观模式 (Facade)</strong></p><ul><li>为复杂子系统提供简化接口</li><li>应用场景: 简化API设计、系统集成</li></ul></li><li><p><strong>享元模式 (Flyweight)</strong></p><ul><li>通过共享技术有效支持大量细粒度对象</li><li>应用场景: 文本编辑器、游戏开发</li></ul></li><li><p><strong>代理模式 (Proxy)</strong></p><ul><li>为其他对象提供代理以控制访问</li><li>应用场景: 远程代理、虚拟代理、保护代理</li></ul></li></ol><h2 id="行为型模式-behavioral-patterns" tabindex="-1">行为型模式 (Behavioral Patterns) <a class="header-anchor" href="#行为型模式-behavioral-patterns" aria-label="Permalink to “行为型模式 (Behavioral Patterns)”">​</a></h2><ol><li><p><strong>责任链模式 (Chain of Responsibility)</strong></p><ul><li>将请求沿着处理链传递, 直到有对象处理它</li><li>应用场景: 事件处理、异常处理</li></ul></li><li><p><strong>命令模式 (Command)</strong></p><ul><li>将请求封装为对象, 支持撤销/重做</li><li>应用场景: GUI操作、事务系统</li></ul></li><li><p><strong>解释器模式 (Interpreter)</strong></p><ul><li>定义语言的文法表示, 并解释执行</li><li>应用场景: 正则表达式、SQL解析</li></ul></li><li><p><strong>迭代器模式 (Iterator)</strong></p><ul><li>提供顺序访问聚合对象元素的方法</li><li>应用场景: 集合遍历、树遍历</li></ul></li><li><p><strong>中介者模式 (Mediator)</strong></p><ul><li>定义对象间的交互集中到中介者对象</li><li>应用场景: 聊天室、GUI组件交互</li></ul></li><li><p><strong>备忘录模式 (Memento)</strong></p><ul><li>捕获并外部化对象内部状态以便恢复</li><li>应用场景: 撤销操作、游戏存档</li></ul></li><li><p><strong>观察者模式 (Observer)</strong></p><ul><li>定义对象间的一对多依赖关系</li><li>应用场景: 事件处理、MVC模式</li></ul></li><li><p><strong>状态模式 (State)</strong></p><ul><li>允许对象在内部状态改变时改变行为</li><li>应用场景: 工作流引擎、游戏角色状态</li></ul></li><li><p><strong>策略模式 (Strategy)</strong></p><ul><li>定义算法族, 封装每个算法并使它们可互换</li><li>应用场景: 排序算法、支付方式</li></ul></li><li><p><strong>模板方法模式 (Template Method)</strong></p><ul><li>定义算法骨架, 将某些步骤延迟到子类</li><li>应用场景: 框架设计、代码复用</li></ul></li><li><p><strong>访问者模式 (Visitor)</strong></p><ul><li>将算法与对象结构分离</li><li>应用场景: 编译器设计、复杂对象结构处理</li></ul></li></ol><h2 id="设计模式选择原则" tabindex="-1">设计模式选择原则 <a class="header-anchor" href="#设计模式选择原则" aria-label="Permalink to “设计模式选择原则”">​</a></h2><ol><li><strong>识别变化点</strong>: 找出系统中可能变化的部分</li><li><strong>面向接口编程</strong>: 而不是面向实现</li><li><strong>优先组合</strong>: 而非继承</li><li><strong>松耦合</strong>: 减少对象间的依赖</li><li><strong>开闭原则</strong>: 对扩展开放, 对修改关闭</li></ol><p>设计模式不是银弹, 过度使用会导致代码复杂化, 应根据实际问题选择合适的模式</p>',11)]))}const h=i(e,[["render",o]]);export{c as __pageData,h as default};
