import{_ as o,c as t,o as r,ag as a}from"./chunks/framework.ko2zIC2c.js";const f=JSON.parse('{"title":"TypeScript 装饰器简介","description":"TypeScript装饰器简介","frontmatter":{"title":"TypeScript 装饰器简介","description":"TypeScript装饰器简介"},"headers":[],"relativePath":"docs/frontend/ts/core/07-1.decorator.md","filePath":"docs/frontend/ts/core/07-1.decorator.md","lastUpdated":1752940917000}'),c={name:"docs/frontend/ts/core/07-1.decorator.md"};function i(l,e,d,n,s,p){return r(),t("div",null,e[0]||(e[0]=[a('<h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h1><blockquote><p>虽然<code>TypeScript5.0</code>种可以之间使用类装饰器, 但为了确保其他装饰器可用, 现阶段使用时, 仍建议使用<code>experimentalDecorators</code>配置来开启装饰器支持, 而且不排除在未来的版本中, 官方会进一步调整装饰器的相关语法</p></blockquote><ol><li>装饰器本质是一种特殊的函数, 可以对类, 属性, 方法, 参数进行扩展, 同时能让代码更简洁</li><li>装饰器自<code>2015</code>年在<code>ECMAScript-6</code>中被提出到现在, 已有<code>10</code>年</li><li>截止目前, 装饰器依然是实验性特性, 需要开发者手动调整配置来开启装饰器支持</li></ol><h2 id="装饰器种类" tabindex="-1">装饰器种类 <a class="header-anchor" href="#装饰器种类" aria-label="Permalink to &quot;装饰器种类&quot;">​</a></h2><ol><li>类装饰器</li><li>属性装饰器</li><li>方法装饰器</li><li>访问装饰器</li><li>参数装饰器</li></ol>',5)]))}const h=o(c,[["render",i]]);export{f as __pageData,h as default};
