import{_ as o,c as a,o as r,ag as t}from"./chunks/framework.ko2zIC2c.js";const u=JSON.parse('{"title":"JavaScript 模块化概述","description":"JavaScript, JS, JavaScript模块化, JS模块化, JavaScript教程, JS教程","frontmatter":{"title":"JavaScript 模块化概述","description":"JavaScript, JS, JavaScript模块化, JS模块化, JavaScript教程, JS教程"},"headers":[],"relativePath":"docs/frontend/js/core/03-1-module-overview.md","filePath":"docs/frontend/js/core/03-1-module-overview.md","lastUpdated":1753957702000}'),i={name:"docs/frontend/js/core/03-1-module-overview.md"};function l(d,e,s,n,c,p){return r(),a("div",null,e[0]||(e[0]=[t('<h1 id="js-模块化" tabindex="-1">JS 模块化 <a class="header-anchor" href="#js-模块化" aria-label="Permalink to &quot;JS 模块化&quot;">​</a></h1><h2 id="模块化概述" tabindex="-1">模块化概述 <a class="header-anchor" href="#模块化概述" aria-label="Permalink to &quot;模块化概述&quot;">​</a></h2><h3 id="什么是模块化" tabindex="-1">什么是模块化 <a class="header-anchor" href="#什么是模块化" aria-label="Permalink to &quot;什么是模块化&quot;">​</a></h3><ul><li>将程序文件依据一定规则<strong>拆分</strong>成多个文件, 这种编码方式就是<strong>模块化</strong>的编码方式</li><li>拆分处理的<strong>每个文件就是一个模块</strong>, 模块化中的数据都是<strong>私有的</strong>, 模块之间<strong>互相隔离</strong></li><li>同时也能通过一些手段, 可以把模块内的指定数据<strong>交出去</strong>, 供其他模块使用</li></ul><h3 id="为什么需要模块化" tabindex="-1">为什么需要模块化 <a class="header-anchor" href="#为什么需要模块化" aria-label="Permalink to &quot;为什么需要模块化&quot;">​</a></h3><p>随着应用的复杂度越来越高, 其代码量和文件数量都会急剧增加, 逐渐引发以下问题:</p><ul><li><p>全局污染问题</p><p>例如一个<code>.html</code>文件引入的多个<code>.js</code>文件中有变量或函数命名冲突, 后引入的就会把前面引入的覆盖</p></li><li><p>依赖混乱问题</p><p>例如引入的<code>Jquery.xxx.js</code>顺序不能乱, 否则就会报错</p></li><li><p>数据安全问题</p><p>例如<code>user.js</code>定义的有用户敏感信息, 虽然定义的函数只返回了部分信息, 但是仍然可以在<code>window</code>上拿到全部信息</p></li></ul><h3 id="模块化规范有哪些" tabindex="-1">模块化规范有哪些 <a class="header-anchor" href="#模块化规范有哪些" aria-label="Permalink to &quot;模块化规范有哪些&quot;">​</a></h3><p>历史背景(了解即可):</p><blockquote><p>2009 年, 随着 Node.js 的出现, JS 在服务器端的应用逐渐增多, 为了让 Node.js 的代码更好维护, 就必须要制定一种 Node.js 环境下的模块化规范</p><p>来自 Mozilla 的工程师 Kevin Dangoor 提出了 CommonJS 规范(初期名字叫做 ServerJS), 随后 Node.js 社区采纳了这一规范</p></blockquote><p>随着时间的推移, 针对<code>JS</code>的不同运行环境, 相继出现了多种模块化规范, 按时间排序分别为:</p><ol><li><code>CommonJS</code>: 服务端应用广泛</li><li><code>AMD</code></li><li><code>CMD</code></li><li><code>ES6 Module</code>: 浏览器端应用广泛</li></ol><h3 id="导入与导出的概念" tabindex="-1">导入与导出的概念 <a class="header-anchor" href="#导入与导出的概念" aria-label="Permalink to &quot;导入与导出的概念&quot;">​</a></h3><p>模块化的核心思想: 模块之间是<strong>互相隔离</strong>的, 通过<strong>导入</strong>和<strong>导出</strong>进行数据和功能的共享</p><ul><li>导出(暴露): 模块公开其内部的一部分(如变量和函数等), 使这些内容可以被其他模块使用</li><li>导入(引入): 模块引入和使用其他模块导出的内容, 以重用代码和功能</li></ul>',15)]))}const S=o(i,[["render",l]]);export{u as __pageData,S as default};
