import{_ as o,c as d,o as c,ag as a}from"./chunks/framework.ko2zIC2c.js";const i="/images/vue/v2/list-key-index.png",t="/images/vue/v2/list-key-id.png",k=JSON.parse('{"title":"Vue2 列表渲染","description":"Vue2, Vue2 Diff算法渲染列表, Vue.js, Vue2教程, Vue2从入门到精通","frontmatter":{"title":"Vue2 列表渲染","description":"Vue2, Vue2 Diff算法渲染列表, Vue.js, Vue2教程, Vue2从入门到精通"},"headers":[],"relativePath":"docs/frontend/vue/core/v2/07-diff.md","filePath":"docs/frontend/vue/core/v2/07-diff.md","lastUpdated":1754039919000}'),l={name:"docs/frontend/vue/core/v2/07-diff.md"};function r(n,e,s,u,f,p){return c(),d("div",null,e[0]||(e[0]=[a('<h1 id="列表渲染" tabindex="-1">列表渲染 <a class="header-anchor" href="#列表渲染" aria-label="Permalink to &quot;列表渲染&quot;">​</a></h1><p><code>Vue 2</code>使用<code>Virtual DOM</code>(虚拟<code>DOM</code>)来提高渲染效率, 其核心是高效的<code>diff</code>算法(也称为<code>patch</code>算法)</p><p><code>diff</code>算法算法用于比较新旧虚拟<code>DOM</code>树的差异, 并最小化对实际<code>DOM</code>的操作</p><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><ul><li><code>Virtual DOM</code>：轻量级的<code>JavaScript</code>对象, 表示真实<code>DOM</code>的结构</li><li><code>Diff</code>算法: 比较新旧<code>Virtual DOM</code>的差异, 找出需要更新的部分</li><li><code>Patch</code>: 将差异应用到真实 DOM 上</li></ul><h2 id="diff-算法核心策略" tabindex="-1">Diff 算法核心策略 <a class="header-anchor" href="#diff-算法核心策略" aria-label="Permalink to &quot;Diff 算法核心策略&quot;">​</a></h2><p><code>Vue 2</code>的<code>diff</code>算法采用以下策略来优化性能:</p><ul><li><strong>同级比较</strong>: 只比较同一层次的节点, 不跨层级比较</li><li><strong>双端比较</strong>: 同时从新旧节点的两端向中间比较</li><li><strong><code>key</code>的重要性</strong>: 使用<code>key</code>来识别节点身份, 提高复用效率</li></ul><h2 id="虚拟-dom-中-key-的作用" tabindex="-1">虚拟 DOM 中 key 的作用 <a class="header-anchor" href="#虚拟-dom-中-key-的作用" aria-label="Permalink to &quot;虚拟 DOM 中 key 的作用&quot;">​</a></h2><p><code>key</code>是虚拟<code>DOM</code>对象的标识, 当状态中的数据发生变化时, <code>Vue</code>会根据<strong>新数据</strong>生成<strong>新的虚拟<code>DOM</code></strong></p><p>随后<code>Vue</code>将**新虚拟<code>DOM</code><strong>与</strong>旧虚拟<code>DOM</code>**进行差异比较</p><h2 id="对比规则" tabindex="-1">对比规则 <a class="header-anchor" href="#对比规则" aria-label="Permalink to &quot;对比规则&quot;">​</a></h2><p>旧虚拟<code>DOM</code>中找到了与新虚拟<code>DOM</code>相同的<code>key</code>:</p><ul><li>若虚拟<code>DOM</code>中内容没变, 为了节省性能会直接使用之前的真实<code>DOM</code>, 不会重新渲染</li><li>若虚拟<code>DOM</code>中内部变了, 则生成新的真实<code>DOM</code>, 随后替换掉页面中之前的真实<code>DOM</code></li></ul><p>旧虚拟<code>DOM</code>中未找到与新虚拟<code>DOM</code>相同的<code>key</code>:</p><ul><li>创建新的真实<code>DOM</code>, 随后渲染到页面中</li></ul><h2 id="为什么不要使用下标作为-key" tabindex="-1">为什么不要使用下标作为 key <a class="header-anchor" href="#为什么不要使用下标作为-key" aria-label="Permalink to &quot;为什么不要使用下标作为 key&quot;">​</a></h2><p>若对数据进行逆向添加、逆向删除等破坏顺序的操作时:</p><ul><li>会产生没有毕要的真实<code>DOM</code>更新, 页面效果没问题但效率低</li></ul><p>若结构中包含输入类的<code>DOM</code>时:</p><ul><li>会产生错误的<code>DOM</code>更新, 页面会出问题</li></ul><h2 id="如何渲染-key" tabindex="-1">如何渲染 key <a class="header-anchor" href="#如何渲染-key" aria-label="Permalink to &quot;如何渲染 key&quot;">​</a></h2><p>最好使用每条数据的唯一标识作为<code>key</code>, 比如<code>id</code>、手机号、身份证号、学号等唯一值</p><p>如果不存在对数据的逆向添加、逆向删除等破坏顺序的操作, 仅用于渲染列表展示, 使用下标<code>index</code>作为<code>key</code>是没有问题的</p><h2 id="示例图" tabindex="-1">示例图 <a class="header-anchor" href="#示例图" aria-label="Permalink to &quot;示例图&quot;">​</a></h2><ul><li>将下标<code>index</code>作为<code>key</code>时</li></ul><p><img src="'+i+'" alt="index-key"></p><ul><li>将唯一<code>id</code>作为<code>key</code>时</li></ul><p><img src="'+t+'" alt="id-key"></p>',29)]))}const D=o(l,[["render",r]]);export{k as __pageData,D as default};
