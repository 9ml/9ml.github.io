import{_ as o,c as i,o as a,ag as t}from"./chunks/framework.ko2zIC2c.js";const l="/images/vue/v2/components-normal.jpg",s="/images/vue/v2/components-vue.jpg",d="/images/vue/v2/components-vm.jpg",c="/images/vue/v2/vueComponent.jpg",b=JSON.parse('{"title":"Vue2 组件","description":"Vue2, Vue2生命周期, Vue.js, Vue2教程, Vue2从入门到精通","frontmatter":{"title":"Vue2 组件","description":"Vue2, Vue2生命周期, Vue.js, Vue2教程, Vue2从入门到精通"},"headers":[],"relativePath":"docs/frontend/vue/core/v2/13-components.md","filePath":"docs/frontend/vue/core/v2/13-components.md","lastUpdated":1754039919000}'),n={name:"docs/frontend/vue/core/v2/13-components.md"};function p(h,e,r,u,m,k){return a(),i("div",null,e[0]||(e[0]=[t('<h1 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-label="Permalink to &quot;组件&quot;">​</a></h1><p>用来实现局部功能效果的代码集合</p><h2 id="理解组件" tabindex="-1">理解组件 <a class="header-anchor" href="#理解组件" aria-label="Permalink to &quot;理解组件&quot;">​</a></h2><h3 id="传统方式编写应用" tabindex="-1">传统方式编写应用 <a class="header-anchor" href="#传统方式编写应用" aria-label="Permalink to &quot;传统方式编写应用&quot;">​</a></h3><p><img src="'+l+'" alt="Component Normal"></p><p>存在的问题:</p><ul><li>依赖关系混乱, 不好维护</li><li>代码复用率不高</li></ul><h3 id="组件方式编写应用" tabindex="-1">组件方式编写应用 <a class="header-anchor" href="#组件方式编写应用" aria-label="Permalink to &quot;组件方式编写应用&quot;">​</a></h3><p><img src="'+s+'" alt="组件方式编写应用"><img src="'+d+'" alt="组件方式编写应用"></p><p>优点:</p><ul><li>复用代码</li><li>简化项目编码</li><li>提高运行效率</li></ul><h3 id="模块化与组件化" tabindex="-1">模块化与组件化 <a class="header-anchor" href="#模块化与组件化" aria-label="Permalink to &quot;模块化与组件化&quot;">​</a></h3><p>模块化:</p><ul><li>当应用中的<code>JS</code>都以模块来编写, 那这个应用就是一个模块化应用</li></ul><p>组件化:</p><ul><li>当应用中的功能都是多组件的方式编写的, 那这个应用就是一个组件化的应用</li></ul><h2 id="使用组件" tabindex="-1">使用组件 <a class="header-anchor" href="#使用组件" aria-label="Permalink to &quot;使用组件&quot;">​</a></h2><p><code>Vue</code>中使用组件的三个步骤:</p><ol><li>定义组件(创建组件)</li><li>注册组件</li><li>使用组件(写组件标签)</li></ol><h3 id="定义组件" tabindex="-1">定义组件 <a class="header-anchor" href="#定义组件" aria-label="Permalink to &quot;定义组件&quot;">​</a></h3><p>使用<code>Vue.extend(options)</code>创建组件, 其中<code>options</code>和<code>new Vue(options)</code>时传入的那个<code>options</code>几乎一致, 区别如下:</p><ul><li>不需要<code>el</code>配置项, 因为最终所有组件都要经过一个<code>Vue</code>实例来管理, 由实例中的<code>el</code>来决定服务于哪个容器</li><li><code>data</code>必须写成函数, 避免组件被复用时, 数据存在引用关系</li><li>使用<code>template</code>可以配置组件结构</li></ul><h3 id="注册组件" tabindex="-1">注册组件 <a class="header-anchor" href="#注册组件" aria-label="Permalink to &quot;注册组件&quot;">​</a></h3><p>局部注册: 在<code>new Vue(options)</code>时传入<code>components</code>选项 全局注册: 使用<code>Vue.component(&#39;组件名&#39;, 组件)</code></p><h3 id="编写组件标签" tabindex="-1">编写组件标签 <a class="header-anchor" href="#编写组件标签" aria-label="Permalink to &quot;编写组件标签&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">注意</p><p>关于组件名:</p><ul><li>一个单词组成: <ul><li>第一种写法: <code>user</code></li><li>第二种写法: <code>User</code></li></ul></li><li>多个单词组成: <ul><li>第一种写法: <code>my-user</code></li><li>第二种写法: <code>MyUser</code>, 需要<code>Vue</code>脚手架支持</li></ul></li><li>备注: <ul><li>组件名尽可能回避<code>HTML</code>中已有的元素名称, 例如: <code>p、h1、H1</code>等都不可以使用</li><li>可以使用<code>name</code>配置项指定组件在开发者工具中呈现的名字</li></ul></li></ul><p>关于组件标签:</p><ul><li>第一种写法: <code>&lt;user&gt;&lt;/user&gt;</code></li><li>第二种写法: <code>&lt;User&gt;&lt;/User&gt;</code></li><li>第三种写法: <code>&lt;User /&gt;</code>, 注意不使用脚手架时, 这种写法会导致后续组件不能渲染</li></ul><p>简写方式:</p><ul><li><code>const app = Vue.extend(options)</code>可简写为: <code>const app = options</code></li></ul></div><h2 id="非单文件组件" tabindex="-1">非单文件组件 <a class="header-anchor" href="#非单文件组件" aria-label="Permalink to &quot;非单文件组件&quot;">​</a></h2><p>一个组件中包含多个组件</p><h2 id="单文件组件" tabindex="-1">单文件组件 <a class="header-anchor" href="#单文件组件" aria-label="Permalink to &quot;单文件组件&quot;">​</a></h2><p>一个组件中只包含一个组件</p><h2 id="vuecomponent" tabindex="-1">VueComponent <a class="header-anchor" href="#vuecomponent" aria-label="Permalink to &quot;VueComponent&quot;">​</a></h2><p>组件本质是一个名为<code>VueComponent</code>的构造函数, 且不是开发者定义的, 是<code>Vue.extend</code>生成的</p><p>开发者只需写<code>&lt;user&gt;&lt;/user&gt;</code>或<code>&lt;user /&gt;</code>, <code>Vue</code>解析时会帮我们创建<code>user</code>组件的实例对象, 及执行: <code>new VueComponent(options)</code></p><p>关于<code>this</code>指向:</p><ul><li>组件配置中<code>data</code>函数、<code>methods</code>中的函数、<code>watch</code>中的函数、<code>computed</code>中的函数的<code>this</code>均是<code>VueComponent</code>实例对象</li><li><code>new Vue</code>中<code>data</code>函数、<code>methods</code>中的函数、<code>watch</code>中的函数、<code>computed</code>中的函数的<code>this</code>均是<code>Vue</code>实例对象</li></ul><p><code>VueComponent</code>的实例对象, 简称<code>vc</code>也可成为组件实例对象</p><p><code>Vue</code>的实例对象, 简称<code>vm</code></p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>每次调用<code>Vue.extend</code>时, 返回的都是一个全新的<code>VueComponent</code></p></div><h2 id="一个重要的内置关系" tabindex="-1">一个重要的内置关系 <a class="header-anchor" href="#一个重要的内置关系" aria-label="Permalink to &quot;一个重要的内置关系&quot;">​</a></h2><p>让组件实例对象<code>vc</code>可以访问到<code>Vue</code>原型上的属性、方法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VueComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span></code></pre></div><p><img src="'+c+'" alt="VueComponent"></p>',44)]))}const V=o(n,[["render",p]]);export{b as __pageData,V as default};
