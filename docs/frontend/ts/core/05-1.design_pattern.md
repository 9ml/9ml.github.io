---
title: 'TypeScript 设计模式简介'
description: 'TypeScript设计模式简介'
---

# 设计模式 (Design Patterns)

设计模式是软件设计中常见问题的典型解决方案, 是经过验证的、可重用的设计经验总结, 以下是主要设计模式的分类和概述:

## 创建型模式 (Creational Patterns)

1. **单例模式 (Singleton)**
   - 确保一个类只有一个实例, 并提供全局访问点
   - 应用场景: 配置管理、日志记录器、数据库连接

2. **工厂方法模式 (Factory Method)**
   - 定义创建对象的接口, 让子类决定实例化哪个类
   - 应用场景: 框架设计、跨平台UI组件创建

3. **抽象工厂模式 (Abstract Factory)**
   - 创建相关或依赖对象的家族, 而不需指定具体类
   - 应用场景: 跨平台GUI工具包、数据库访问层

4. **建造者模式 (Builder)**
   - 分步骤构建复杂对象, 允许不同表示
   - 应用场景: 复杂对象创建(如SQL查询构造器)

5. **原型模式 (Prototype)**
   - 通过复制现有对象来创建新对象
   - 应用场景: 对象创建成本高时(如数据库查询结果)

## 结构型模式 (Structural Patterns)

1. **适配器模式 (Adapter)**
   - 使接口不兼容的类能够一起工作
   - 应用场景: 集成旧系统、使用第三方库

2. **桥接模式 (Bridge)**
   - 将抽象与实现分离, 使它们可以独立变化
   - 应用场景: 跨平台应用、多数据库支持

3. **组合模式 (Composite)**
   - 以树形结构组合对象, 表示部分-整体层次
   - 应用场景: UI组件、文件系统表示

4. **装饰器模式 (Decorator)**
   - 动态地给对象添加额外职责
   - 应用场景: 流处理、权限检查

5. **外观模式 (Facade)**
   - 为复杂子系统提供简化接口
   - 应用场景: 简化API设计、系统集成

6. **享元模式 (Flyweight)**
   - 通过共享技术有效支持大量细粒度对象
   - 应用场景: 文本编辑器、游戏开发

7. **代理模式 (Proxy)**
   - 为其他对象提供代理以控制访问
   - 应用场景: 远程代理、虚拟代理、保护代理

## 行为型模式 (Behavioral Patterns)

1. **责任链模式 (Chain of Responsibility)**
   - 将请求沿着处理链传递, 直到有对象处理它
   - 应用场景: 事件处理、异常处理

2. **命令模式 (Command)**
   - 将请求封装为对象, 支持撤销/重做
   - 应用场景: GUI操作、事务系统

3. **解释器模式 (Interpreter)**
   - 定义语言的文法表示, 并解释执行
   - 应用场景: 正则表达式、SQL解析

4. **迭代器模式 (Iterator)**
   - 提供顺序访问聚合对象元素的方法
   - 应用场景: 集合遍历、树遍历

5. **中介者模式 (Mediator)**
   - 定义对象间的交互集中到中介者对象
   - 应用场景: 聊天室、GUI组件交互

6. **备忘录模式 (Memento)**
   - 捕获并外部化对象内部状态以便恢复
   - 应用场景: 撤销操作、游戏存档

7. **观察者模式 (Observer)**
   - 定义对象间的一对多依赖关系
   - 应用场景: 事件处理、MVC模式

8. **状态模式 (State)**
   - 允许对象在内部状态改变时改变行为
   - 应用场景: 工作流引擎、游戏角色状态

9. **策略模式 (Strategy)**
   - 定义算法族, 封装每个算法并使它们可互换
   - 应用场景: 排序算法、支付方式

10. **模板方法模式 (Template Method)**
    - 定义算法骨架, 将某些步骤延迟到子类
    - 应用场景: 框架设计、代码复用

11. **访问者模式 (Visitor)**
    - 将算法与对象结构分离
    - 应用场景: 编译器设计、复杂对象结构处理

## 设计模式选择原则

1. **识别变化点**: 找出系统中可能变化的部分
2. **面向接口编程**: 而不是面向实现
3. **优先组合**: 而非继承
4. **松耦合**: 减少对象间的依赖
5. **开闭原则**: 对扩展开放, 对修改关闭

设计模式不是银弹, 过度使用会导致代码复杂化, 应根据实际问题选择合适的模式
