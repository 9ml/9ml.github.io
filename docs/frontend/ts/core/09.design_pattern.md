---
title: 'TypeScript 设计模式'
---

# 设计模式

## 单例模式

> 让一个类只能产生一个对象, 不论外部调用多少次, 始终都是同一个对象
>
> 一般用于管理类, 如系统管理类, 声音管理类等

```ts
// 创建一个声音管理类 方式一
class SoundManager {
  // 在内部实例化
  static init = new SoundManager()
  // 将构造函数设置为私有的, 外部就无法通过 new 关键字实例化
  private constructor () {}
}

// 外部使用
SoundManager.init

// 创建一个敌人管理类 方式二(推荐), 相对节省内存
class EnemyManager {
  private static instance: EnemyManager
  private constructor() {}
  static Init() {
    // 当前单例是否产生, 懒加载, 不实用时节省内存
    if (!this.instance) {
      EnemyManager.instance = new EnemyManager()
    }
    return EnemyManager.instance
  }
}

// 外部使用
EnemyManager.Init()
```

## 代理模式

> 代理模式是一种结构型设计模式, 它允许你提供一个代理对象来控制对另一个对象的访问
>
> 代理可以在客户端和目标对象之间充当中间层, 用于增强功能, 控制访问或延迟初始化
>
> 代理模式是一对多

```ts
interface CalcInterface {
  cacl: (x: number, y: number) => number
}

class Person {
  // 代理
  delegate: CalcInterface;
  constructor(delegate: CalcInterface) {
    this.delegate = delegate
  }
  // 计算
  getRes(a: number, b: number) {
    let res = this.delegate.cacl(a, b)
    console.log(res)
  }
}

class DoneA implements CalcInterface {
  cacl(x: number, y: number) {
    return x + y
  }
}

class DoneB implements CalcInterface {
  cacl(x: number, y: number) {
    return x - y
  }
}

// 创建实例传入代理
const man = new Person(new DoneA())
man.getRes(3, 4)
```

## 观察者模式

> 一个对象中的状态可以被其他对象监听, 当对象中的状态改变时, 会通知所有监听的对象
>
> 观察者模式是多对一

```ts
// 定义协议, 谁监听就要遵循这个规范
interface IObserver {
  nameChangeed: (newName: string) => void
}

class Person {
  private _name: string
  // 观察者数组
  observers: IObserver[]
  constructor(name: string, observers: IObserver[]) {
    this._name = name
    this.observers = observers
  }

  get name() {
    return this._name
  }

  set name(v) {
    this._name = v
    // 发生变化时遍历观察者数组, 给数组中的每一个观察者发送通知
    for(let i of this.observers) {
      i.nameChangeed(this._name)
    }
  }
}

class Test implements IObserver {
  nameChangeed(newName: string) {
    console.log(`监听到变化, name变为: ${newName}`)
  }
}

// 实例化传入观察者
let p = new Person('张三', [new Test()])
p.name = '李四'
// 监听到变化, name变为: 李四
```

## 工厂模式

> 不关心过程, 只需要结果

```ts
// 汽车类型
enum CarType {
  BMW,
  Audi,
  Benz,
}

class Car {
  constructor(public name: string) {}
  // 工厂方法
  static create(type: CarType): Car {
    let car: Car;
    switch (type) {
      case CarType.BMW:
        car = new BWMCar("宝马");
        break;
      case CarType.Audi:
        car = new BWMCar("奥迪");
        break;
      case CarType.Benz:
        car = new BWMCar("奔驰");
        break;
    }
    return car;
  }
}

class BWMCar extends Car {}
class AudiCar extends Car {}
class BenzCar extends Car {}

const bmw = Car.create(CarType.BMW)
const audi = Car.create(CarType.Audi)
const benz = Car.create(CarType.Benz)
```
